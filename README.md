What was the problem you were solving in the projects for this course?
In both Projects, I was working on how to organize course data in a way that's easy to search and display.
For project one, it was about figuring out how different data structures affect performance, like runtime and memory.
For Project Two, it was about sorting and printing out a clean list of courses in alphanumeric order, including their prerequisits. Both had different goals but were focused on making data easier to work with. 

How did you approach the problem? Consider why data structures are important to understand.
I started thinking about which data structures made the most sense for the problem. In project one, I tried vectors, hash tables, and binary search trees, and then compared them. 
I used my pseudocode to help guide me through each structure. In project two, I focused on getting the courses to sort correctly and making sure they printed our the way the assignment ask.
I also tested small pieces of code before putting them all together to avoid confusion later. 

How did you overcome any roadblocks you encountered while going through the activities or project?
There were a few times I got stuck, especially when reading data from the file and trying to handle formatting issues or missing prerequisites.
I just kept stepping through the code, printing out valves, and testing changes one at a time. 
It helped me figure out where I went wrong and slowly fix each bug. I didn't give up when it didn't work the first time; I just kept trying until it did.

How has your work on this project expanded your approach to designing software and developing programs?
Before this class, I didn't always think about performance or data structure choices. Now, I take more time to plan things out. I think about what structure will work best,
and I also look at how much memory or time it might use. I also wrote more pseudocode than I used to, which really helps me stay organized. I feel more confident in
designing programs from scratch. 

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
My code is more organized now. I used better naming, I split up logic into smaller parts, and I comment more. It's easier to come back later and know what my code is doing.
I also write code in a way that's easier to adapt if I need to change something. I try to keep things readable, not just for myself but for anyone else who might look at it,
like a teammate or future employer. 
